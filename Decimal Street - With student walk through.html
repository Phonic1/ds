<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Place Value Math Tool</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Fredoka:wght@400;700&display=swap" rel="stylesheet">
    
    <style>
        :root { --square-size: 15px; }
        body { font-family: 'Fredoka', sans-serif; background-color: #f4f7f9; display: flex; flex-direction: column; align-items: center; padding-top: 100px; padding-bottom: 150px; transition: background-color 0.3s ease; }
        .ui-panel { padding: 15px 25px; background-color: white; border-radius: 12px; box-shadow: 0 4px 15px rgba(0,0,0,0.08); display: flex; align-items: center; gap: 15px; transition: background-color 0.3s ease, color 0.3s ease; }
        
        #student-info { position: fixed; top: 20px; left: 20px; z-index: 10; padding: 10px 15px; }

        #controls-wrapper { position: fixed; bottom: 20px; left: 20px; z-index: 10; display: flex; flex-direction: column; align-items: flex-start; gap: 10px; }
        #toggle-controls-button { background-color: #8e44ad; color: white; }
        #collapsible-controls { display: none; flex-direction: row; gap: 10px; align-items: flex-end; flex-wrap: wrap; }
        #collapsible-controls.visible { display: flex; }
        
        #teacher-tools, #controls, #color-changer { padding: 10px 15px; font-size: 0.9rem; }
        #slider { width: 100px; }
        #export-button { background-color: #3498db; color: white; }
        #print-button { background-color: #16a085; color: white; }

        .color-button { width: 30px; height: 30px; border-radius: 50%; border: 2px solid #ccc; cursor: pointer; transition: transform 0.2s ease; }
        .color-button:hover { transform: scale(1.1); }
        #main-container { display: flex; align-items: flex-end; justify-content: center; gap: 50px; margin-bottom: 30px; }
        #final-answer { flex-direction: column; gap: 12px; margin-top: 20px; position: relative; /* For confetti positioning */ }
        .grid-group { display: flex; flex-direction: column; align-items: center; gap: 15px; }
        #red-grids-wrapper, #green-grids-wrapper { display: grid; grid-template-columns: repeat(3, auto); gap: 20px; }
        #blue-grids-wrapper { display: flex; gap: 10px; }
        .grid-container, .square { transition: background-color 0.2s ease, transform 0.2s ease, border-color 0.3s ease, outline 0.2s ease-in-out, box-shadow 0.2s ease-in-out; }
        .grid-container { display: grid; background-color: #ffffff; border: 1px solid #ccc; position: relative; }
        .grid-10x10 { grid-template-columns: repeat(10, var(--square-size)); grid-template-rows: repeat(10, var(--square-size)); }
        .grid-1x10 { grid-template-columns: var(--square-size); grid-template-rows: repeat(10, var(--square-size)); }
        .square { width: var(--square-size); height: var(--square-size); box-sizing: border-box; border: 1px solid black; cursor: pointer; }
        .red { background-color: #e74c3c; transform: scale(1.05); }
        .blue { background-color: #3498db; transform: scale(1.05); }
        .green { background-color: #2ecc71; transform: scale(1.05); }
        #name-input { font-size: 1.1rem; padding: 8px; width: 140px; border: 2px solid #ccc; border-radius: 8px; font-family: 'Fredoka', sans-serif; }
        #answer-input { font-size: 1.8rem; padding: 10px; width: 140px; text-align: center; border: 2px solid #ccc; border-radius: 8px; font-family: 'Fredoka', sans-serif; }
        .button { padding: 12px 24px; border: none; border-radius: 8px; font-size: 1.1rem; font-weight: bold; cursor: pointer; transition: transform 0.1s, background-color 0.2s; }
        .button:active { transform: scale(0.95); }
        .button:disabled { background-color: #95a5a6; cursor: not-allowed; }
        #check-button { background-color: #27ae60; color: white; }
        #reset-button { background-color: #e67e22; color: white; }
        #feedback-message { font-size: 1.5rem; font-weight: bold; min-height: 30px; margin-top: 10px; text-align: center; position: relative; }
        .correct { color: #27ae60; }
        .incorrect { color: #c0392b; }
        
        #difficulty-selector { display: flex; justify-content: center; gap: 20px; margin-bottom: 10px; font-size: 1rem; font-weight: bold;}
        #difficulty-selector label { cursor: pointer; display: flex; align-items: center; gap: 5px; }

        body.dark-mode { color: #ecf0f1; }
        body.dark-mode .ui-panel { background-color: #34495e; color: #ecf0f1; }
        body.dark-mode .grid-container { background-color: #34495e; border-color: #7f8c8d; }
        body.dark-mode .square { border-color: #ecf0f1; }
        body.dark-mode input { background-color: #5d6d7e; color: #ecf0f1; border-color: #7f8c8d; }
        body.dark-mode .correct { color: #2ecc71; }
        body.dark-mode .incorrect { color: #e74c3c; }
        body.dark-mode .red, body.dark-mode .red:hover { background-color: #e74c3c; }
        body.dark-mode .blue, body.dark-mode .blue:hover { background-color: #3498db; }
        body.dark-mode .green, body.dark-mode .green:hover { background-color: #2ecc71; }

        .highlight { outline: 4px solid gold; outline-offset: 4px; transform: scale(1.15) !important; box-shadow: 0 0 25px gold; z-index: 100; }
        .confetti-container { position: absolute; top: -80px; left: 0; width: 100%; height: calc(100% + 150px); pointer-events: none; z-index: 1000; overflow: hidden; }
        .confetti { position: absolute; width: 10px; height: 10px; background-color: #f00; opacity: 0; animation: fall 3s linear forwards; }
        @keyframes fall {
            0% { opacity: 1; transform: translateY(0) rotateZ(0deg); }
            100% { opacity: 0; transform: translateY(400px) rotateZ(720deg); }
        }

        #print-container { display: none; }
        @media print {
            body > * { display: none !important; }
            #print-container { display: block !important; }
            * { -webkit-print-color-adjust: exact !important; print-color-adjust: exact !important; }
            @page { margin: 1in; }
            .print-attempt-block { margin-top: 40px; padding-top: 20px; border-top: 1px solid #ccc; page-break-inside: avoid; }
        }
    </style>
</head>
<body>
    <div id="student-info" class="ui-panel">
        <label for="name-input" style="font-weight: bold;">Name:</label>
        <input type="text" id="name-input" placeholder="Your name">
    </div>

    <div id="controls-wrapper">
        <button id="toggle-controls-button" class="button">Controls</button>
        <div id="collapsible-controls">
            <!-- controls content -->
        </div>
    </div>

    <div id="main-container">
        <div class="grid-group"><div id="red-grids-wrapper"></div></div>
        <div class="grid-group"><div id="blue-grids-wrapper"></div></div>
        <div class="grid-group"><div id="green-grids-wrapper"></div></div>
    </div>

    <div id="final-answer" class="ui-panel">
        <!-- final answer content -->
    </div>

    <div id="print-container"></div>

    <script>
        const ELEVENLABS_API_KEY = 'sk_752823d799d70fcbca6c5e89f94c9e4a16423097299c5312';
        const ELEVENLABS_VOICE_ID = '21m00Tcm4TlvDq8ikWAM'; 
        let browserFemaleVoice = null;
        let progressLog = [];
        let currentCorrectValue = 0;

        // --- ROBUST SPEECH CONTROL SYSTEM ---
        let isSpeechLocked = false;
        let currentApiAudio = null;

        function forceStopAudio() {
            window.speechSynthesis.cancel(); // Force-stop browser TTS
            if (currentApiAudio) {
                currentApiAudio.pause();
                currentApiAudio.src = ''; // Detach source to prevent further loading
                currentApiAudio = null;
            }
            isSpeechLocked = false; // Release the lock
        }

        async function speak(text) {
            // 1. Wait until the lock is free. This prevents any overlap.
            while (isSpeechLocked) {
                await new Promise(resolve => setTimeout(resolve, 50));
            }

            // 2. Acquire the lock for ourselves.
            isSpeechLocked = true;

            return new Promise(async (resolve) => {
                const onEnd = () => {
                    isSpeechLocked = false; // 3. Release the lock when done.
                    resolve();
                };
                
                const onError = (err) => {
                    console.error("Speech Error:", err);
                    onEnd(); // Also release lock on error to prevent getting stuck.
                };

                // Fallback to browser TTS
                const fallbackSpeak = () => {
                    console.warn("Using browser's built-in TTS.");
                    const u = new SpeechSynthesisUtterance(text);
                    if (browserFemaleVoice) u.voice = browserFemaleVoice;
                    u.rate = 0.9;
                    u.onend = onEnd;
                    u.onerror = onError;
                    window.speechSynthesis.cancel();
                    window.speechSynthesis.speak(u);
                };

                // Try ElevenLabs API first
                if (ELEVENLABS_API_KEY && ELEVENLABS_VOICE_ID) {
                    try {
                        const response = await fetch(`https://api.elevenlabs.io/v1/text-to-speech/${ELEVENLABS_VOICE_ID}`, { method: 'POST', headers: { 'Accept': 'audio/mpeg', 'Content-Type': 'application/json', 'xi-api-key': ELEVENLABS_API_KEY }, body: JSON.stringify({ text, model_id: "eleven_multilingual_v2", voice_settings: { stability: 0.5, similarity_boost: 0.75 } }) });
                        if (!response.ok) throw new Error(`API Error: ${response.statusText}`);
                        
                        currentApiAudio = new Audio(URL.createObjectURL(await response.blob()));
                        currentApiAudio.onended = onEnd;
                        currentApiAudio.onerror = onError;
                        currentApiAudio.play();
                    } catch (error) {
                        console.error("API call failed, using fallback.", error);
                        fallbackSpeak();
                    }
                } else {
                    fallbackSpeak();
                }
            });
        }
        
        // --- NEW: BROWSER-ONLY SPEECH FUNCTION ---
        // This function is specifically for the guided correction counting.
        async function speakWithBrowser(text) {
            // 1. Wait until the lock is free.
            while (isSpeechLocked) {
                await new Promise(resolve => setTimeout(resolve, 50));
            }

            // 2. Acquire the lock.
            isSpeechLocked = true;

            return new Promise((resolve) => {
                const onEnd = () => {
                    isSpeechLocked = false; // 3. Release the lock.
                    resolve();
                };

                const onError = (err) => {
                    console.error("Browser Speech Error:", err);
                    onEnd(); // Release lock on error to prevent getting stuck.
                };

                const u = new SpeechSynthesisUtterance(text);
                if (browserFemaleVoice) u.voice = browserFemaleVoice;
                u.rate = 0.9;
                u.onend = onEnd;
                u.onerror = onError;
                window.speechSynthesis.cancel();
                window.speechSynthesis.speak(u);
            });
        }


        function loadBrowserVoice() {
            const voices = window.speechSynthesis.getVoices();
            if (voices.length > 0) {
                browserFemaleVoice = voices.find(v => v.lang === 'en-GB' && v.name.includes('Female')) ||
                                   voices.find(v => v.lang === 'en-US' && v.name.includes('Female')) ||
                                   voices.find(v => v.lang.startsWith('en-'));
            }
        }
        // --- END OF SPEECH SYSTEM ---

        // --- MODIFIED: showGuidedCorrection now uses speakWithBrowser for counting ---
        async function showGuidedCorrection() {
            const pause = (ms) => new Promise(resolve => setTimeout(resolve, ms));
            const hundredsGrids = document.querySelectorAll('.grid-10x10.red');
            const tensGrids = document.querySelectorAll('.grid-1x10.blue');
            const onesGrids = document.querySelectorAll('.square.grid-1x1.green');
            let currentCount = 0;
            
            await pause(200);

            for (const grid of hundredsGrids) {
                currentCount += 100;
                grid.classList.add('highlight');
                await speakWithBrowser(`${currentCount}`); // Use browser voice for counting
                await pause(100);
                grid.classList.remove('highlight');
                await pause(100);
            }
            for (const grid of tensGrids) {
                currentCount += 10;
                grid.classList.add('highlight');
                await speakWithBrowser(`${currentCount}`); // Use browser voice for counting
                await pause(100);
                grid.classList.remove('highlight');
                await pause(100);
            }
            for (const grid of onesGrids) {
                currentCount += 1;
                grid.classList.add('highlight');
                await speakWithBrowser(`${currentCount}`); // Use browser voice for counting
                await pause(100);
                grid.classList.remove('highlight');
                await pause(100);
            }
            
            await pause(400);
            const finalMsg = `So the correct number is ${currentCorrectValue}. Let's try a new one!`;
            document.getElementById('feedback-message').textContent = `The answer was ${currentCorrectValue}.`;
            await speak(finalMsg); // Use API voice for the final summary message
            await pause(1000);
        }
        
        function triggerConfetti() {
            const finalAnswerPanel = document.getElementById('final-answer');
            let container = document.getElementById('confetti-container');
            if (container) container.remove(); 
            container = document.createElement('div');
            container.id = 'confetti-container';
            container.classList.add('confetti-container');
            finalAnswerPanel.appendChild(container);
            const colors = ['#27ae60', '#3498db', '#f1c40f', '#e74c3c', '#9b59b6'];
            const confettiCount = 60;
            for (let i = 0; i < confettiCount; i++) {
                const confetti = document.createElement('div');
                confetti.classList.add('confetti');
                confetti.style.left = `${Math.random() * 100}%`;
                confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                confetti.style.animationDelay = `${Math.random() * 0.5}s`;
                confetti.style.animationDuration = `${2 + Math.random() * 2}s`;
                const size = Math.floor(Math.random() * 6) + 6;
                confetti.style.width = `${size}px`;
                confetti.style.height = `${size}px`;
                container.appendChild(confetti);
            }
            setTimeout(() => { if (container) container.remove(); }, 5000);
        }

        function generateNewProblem() {
            const redWrapper = document.getElementById('red-grids-wrapper');
            const blueWrapper = document.getElementById('blue-grids-wrapper');
            const greenWrapper = document.getElementById('green-grids-wrapper');
            const answerInput = document.getElementById('answer-input');
            const feedbackMessage = document.getElementById('feedback-message');
            const selectedDifficulty = document.querySelector('input[name="difficulty"]:checked').value;
            document.querySelectorAll('.red, .blue, .green').forEach(el => el.classList.remove('red', 'blue', 'green'));
            answerInput.value = '';
            feedbackMessage.textContent = '';
            feedbackMessage.className = '';
            if (selectedDifficulty === '2') {
                currentCorrectValue = Math.floor(Math.random() * 90) + 10;
            } else {
                currentCorrectValue = Math.floor(Math.random() * 900) + 100;
            }
            const hundreds = Math.floor(currentCorrectValue / 100);
            const tens = Math.floor((currentCorrectValue % 100) / 10);
            const ones = currentCorrectValue % 10;
            const allHundredGrids = Array.from(redWrapper.querySelectorAll('.grid-10x10'));
            const orderedHundredGrids = [];
            const numCols = 3; 
            for (let col = 0; col < numCols; col++) {
                for (let row = numCols - 1; row >= 0; row--) {
                    const index = (row * numCols) + col;
                    if (allHundredGrids[index]) orderedHundredGrids.push(allHundredGrids[index]);
                }
            }
            for (let i = 0; i < hundreds; i++) { if (orderedHundredGrids[i]) orderedHundredGrids[i].classList.add('red'); }
            const allTenGrids = blueWrapper.querySelectorAll('.grid-1x10');
            for (let i = 0; i < tens; i++) { if(allTenGrids[i]) allTenGrids[i].classList.add('blue'); }
            const allOneGrids = Array.from(greenWrapper.querySelectorAll('.square.grid-1x1'));
            const orderedOneGrids = [];
            for (let col = 0; col < numCols; col++) {
                for (let row = numCols - 1; row >= 0; row--) {
                    const index = (row * numCols) + col;
                    if (allOneGrids[index]) orderedOneGrids.push(allOneGrids[index]);
                }
            }
            for (let i = 0; i < ones; i++) { if(orderedOneGrids[i]) orderedOneGrids[i].classList.add('green'); }
        }

        document.addEventListener('DOMContentLoaded', function() {
            document.getElementById('final-answer').innerHTML = `
                <div id="difficulty-selector">
                    <label><input type="radio" name="difficulty" value="2" checked> 2-Digit (Tens & Units)</label>
                    <label><input type="radio" name="difficulty" value="3"> 3-Digit (Hundreds)</label>
                </div>
                <label for="answer-input" style="font-size: 1.2rem; font-weight:bold;">What number do you see?</label>
                <input type="number" id="answer-input" placeholder="Type here">
                <div>
                    <button id="check-button" class="button">Check Answer</button>
                    <button id="reset-button" class="button">New Question</button>
                </div>
                <div id="feedback-message"></div>`;

            document.getElementById('collapsible-controls').innerHTML = `
                <div id="color-changer" class="ui-panel">
                    <button class="color-button" data-color="#f4f7f9" style="background-color: #f4f7f9;"></button>
                    <button class="color-button" data-color="#fcf8e8" style="background-color: #fcf8e8;"></button>
                    <button class="color-button" data-color="#2c3e50" style="background-color: #2c3e50;"></button>
                </div>
                <div id="teacher-tools" class="ui-panel">
                    <span>Logged: <b id="attempts-count">0</b></span>
                    <button id="export-button" class="button">Export</button>
                    <button id="print-button" class="button">Print</button>
                </div>
                <div id="controls" class="ui-panel">
                    <label for="slider">Size:</label>
                    <input type="range" id="slider" min="5" max="30" value="15">
                    <span id="slider-value">15px</span>
                </div>`;


            const nameInput = document.getElementById('name-input');
            const mainContainer = document.getElementById('main-container');
            const redWrapper = document.getElementById('red-grids-wrapper');
            const blueWrapper = document.getElementById('blue-grids-wrapper');
            const greenWrapper = document.getElementById('green-grids-wrapper');
            const slider = document.getElementById('slider');
            const sliderValue = document.getElementById('slider-value');
            const checkButton = document.getElementById('check-button');
            const resetButton = document.getElementById('reset-button');
            const colorChanger = document.getElementById('color-changer');
            const exportButton = document.getElementById('export-button');
            const toggleControlsButton = document.getElementById('toggle-controls-button');
            const collapsibleControls = document.getElementById('collapsible-controls');
            const printButton = document.getElementById('print-button');
            
            if (window.speechSynthesis.onvoiceschanged !== undefined) {
                window.speechSynthesis.onvoiceschanged = loadBrowserVoice;
            }
            loadBrowserVoice();

            for (let i = 0; i < 9; i++) {
                const gridR = document.createElement('div'); gridR.classList.add('grid-container', 'grid-10x10');
                for (let j = 0; j < 100; j++) { const s = document.createElement('div'); s.classList.add('square'); gridR.appendChild(s); }
                redWrapper.appendChild(gridR);
                const gridB = document.createElement('div'); gridB.classList.add('grid-container', 'grid-1x10');
                for (let j = 0; j < 10; j++) { const s = document.createElement('div'); s.classList.add('square'); gridB.appendChild(s); }
                blueWrapper.appendChild(gridB);
                const gridG = document.createElement('div'); gridG.classList.add('square', 'grid-1x1');
                greenWrapper.appendChild(gridG);
            }
            
            slider.addEventListener('input', e => { document.documentElement.style.setProperty('--square-size', `${e.target.value}px`); sliderValue.textContent = `${e.target.value}px`; });
            
            resetButton.addEventListener('click', () => {
                forceStopAudio();
                generateNewProblem();
            });
            
            checkButton.addEventListener('click', async () => {
                forceStopAudio();

                const answerInput = document.getElementById('answer-input');
                const feedbackMessage = document.getElementById('feedback-message');
                const studentName = nameInput.value.trim() || 'Unnamed Student';
                const correctValue = currentCorrectValue;

                checkButton.disabled = true;
                resetButton.disabled = true;
                answerInput.disabled = true;

                if (answerInput.value.trim() === '') {
                    await speak("Please type a number.");
                    checkButton.disabled = false;
                    resetButton.disabled = false;
                    answerInput.disabled = false;
                    return;
                }
                const userValue = parseInt(answerInput.value);
                const isCorrect = correctValue === userValue;
                const record = { gridState: mainContainer.cloneNode(true), targetValue: correctValue, submittedValue: isNaN(userValue) ? 'N/A' : userValue, result: isCorrect ? 'Correct' : 'Incorrect' };
                progressLog.push(record);
                document.getElementById('attempts-count').textContent = progressLog.length;

                if (isCorrect) {
                    const spokenMsg = studentName !== 'Unnamed Student' ? `Correct! Fantastic work, ${studentName}!` : `Correct! Fantastic work!`;
                    feedbackMessage.textContent = "Correct! Well done!";
                    feedbackMessage.className = 'correct';
                    triggerConfetti();
                    await speak(spokenMsg);
                    await new Promise(resolve => setTimeout(resolve, 1500));
                    generateNewProblem();
                } else {
                    const spokenMsg = `Good try! That wasn’t quite right. Let's count it out together.`;
                    feedbackMessage.textContent = `Not quite. Let's check...`;
                    feedbackMessage.className = 'incorrect';
                    await speak(spokenMsg);
                    await showGuidedCorrection(); 
                    generateNewProblem();
                }
                checkButton.disabled = false;
                resetButton.disabled = false;
                answerInput.disabled = false;
            });

            colorChanger.addEventListener('click', (event) => {
                const button = event.target.closest('.color-button');
                if (!button) return;
                document.body.style.backgroundColor = button.dataset.color;
                document.body.classList.toggle('dark-mode', button.dataset.color === '#2c3e50');
            });
            
            exportButton.addEventListener('click', () => { /* ... export logic ... */ });
            toggleControlsButton.addEventListener('click', () => { collapsibleControls.classList.toggle('visible'); });
            printButton.addEventListener('click', () => { /* ... print logic ... */ });

            generateNewProblem();
        });
    </script>
</body>
</html>