<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Subitising Memory Game — Green Unit Blocks</title>
    <link rel="preconnect" href="https://fonts.googleapis.com"/>
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin/>
    <link href="https://fonts.googleapis.com/css2?family=Fredoka:wght@400;700&display=swap" rel="stylesheet"/>

    <style>
        /* Use a slightly larger default square size for younger students */
        :root { --square-size: 35px; }
        body {
            font-family: 'Fredoka', sans-serif;
            background-color: #f4f7f9;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding-top: 140px;
            padding-bottom: 180px;
            transition: background-color 0.3s ease;
        }
        .ui-panel {
            padding: 15px 25px;
            background-color: white;
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.08);
            display: flex;
            align-items: center;
            gap: 15px;
            transition: background-color 0.3s ease, color 0.3s ease;
        }

        /* Student name */
        #student-info {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 10;
            padding: 10px 15px;
        }

        /* Controls wrapper */
        #controls-wrapper {
            position: fixed;
            bottom: 20px;
            left: 20px;
            z-index: 10;
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 10px;
        }
        #toggle-controls-button {
            background-color: #8e44ad;
            color: white;
        }
        #collapsible-controls {
            display: none;
            flex-direction: row;
            gap: 10px;
            align-items: flex-end;
            flex-wrap: wrap;
        }
        #collapsible-controls.visible {
            display: flex;
        }

        /* Color changer and tools */
        #teacher-tools, #controls, #color-changer {
            padding: 10px 15px;
            font-size: 0.9rem;
        }
        #slider { width: 100px; }
        #export-button { background-color: #3498db; color: white; }
        #print-button { background-color: #16a085; color: white; }
        .color-button {
            width: 30px; height: 30px; border-radius: 50%; border: 2px solid #ccc; cursor: pointer;
            transition: transform 0.2s ease;
        }
        .color-button:hover { transform: scale(1.1); }

        /* Quantity panel and toggle */
        #quantity-wrapper {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 10;
            display: flex;
            flex-direction: column;
            gap: 8px;
            transition: transform 0.5s ease;
        }
        /* When collapsed slide off to the left */
        #quantity-wrapper.collapsed {
            transform: translateX(-110%);
        }
        #quantity-panel {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .qty-button {
            padding: 10px 14px;
            border: none;
            border-radius: 8px;
            font-weight: 700;
            background-color: #27ae60;
            color: #fff;
            cursor: pointer;
            transition: transform 0.1s;
        }
        .qty-button:active { transform: scale(0.96); }
        #reveal-again {
            background-color: #2980b9;
            color: #fff;
        }
        /* Toggle button for quantity panel */
        #toggle-qty-panel {
            padding: 6px 10px;
            border: none;
            border-radius: 8px;
            background-color: #34495e;
            color: #ecf0f1;
            cursor: pointer;
            align-self: flex-start;
        }

        #main-container {
            display: flex;
            align-items: flex-end;
            justify-content: center;
            gap: 50px;
            margin-bottom: 30px;
        }
        #final-answer {
            flex-direction: column;
            gap: 12px;
            margin-top: 20px;
        }
        .grid-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }
        #green-grids-wrapper {
            display: grid;
            grid-template-columns: repeat(3, auto);
            gap: 20px;
        }
        .square {
            width: var(--square-size);
            height: var(--square-size);
            box-sizing: border-box;
            border: 1px solid black;
            cursor: pointer;
            background-color: #ffffff;
            transition: background-color 0.2s ease, transform 0.1s ease, border-color 0.3s ease;
        }
        .green { background-color: #2ecc71; transform: scale(1.05); }

        #name-input, #answer-input {
            font-size: 1.1rem;
            padding: 8px;
            border: 2px solid #ccc;
            border-radius: 8px;
            font-family: 'Fredoka', sans-serif;
        }
        #answer-input {
            font-size: 1.8rem;
            width: 140px;
            text-align: center;
        }
        .button {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 1.1rem;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.1s;
        }
        .button:active { transform: scale(0.95); }
        #check-button { background-color: #27ae60; color: white; }
        #reset-button { background-color: #c0392b; color: white; }
        #feedback-message {
            font-size: 1.5rem;
            font-weight: bold;
            min-height: 30px;
            margin-top: 10px;
            text-align: center;
        }
        .correct { color: #27ae60; }
        .incorrect { color: #c0392b; }
        body.dark-mode { background-color: #2c3e50; color: #ecf0f1; }
        body.dark-mode .ui-panel { background-color: #34495e; color: #ecf0f1; }
        body.dark-mode .square { background-color: #34495e; border-color: #ecf0f1; }
        body.dark-mode input { background-color: #5d6d7e; color: #ecf0f1; border-color: #7f8c8d; }
        body.dark-mode .correct { color: #2ecc71; }
        body.dark-mode .incorrect { color: #e74c3c; }
        body.dark-mode .green,
        body.dark-mode .green:hover { background-color: #2ecc71; }

        /* Mute button styling */
        #mute-button {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 10;
            background-color: #95a5a6;
            color: #fff;
            border: none;
            border-radius: 8px;
            padding: 10px 20px;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }
        #mute-button:hover {
            background-color: #7f8c8d;
        }

        #print-container { display: none; }
        @media print {
            body > * { display: none !important; }
            #print-container { display: block !important; }
            * { -webkit-print-color-adjust: exact !important; print-color-adjust: exact !important; }
            @page { margin: 1in; }
            .print-attempt-block { margin-top: 40px; padding-top: 20px; border-top: 1px solid #ccc; page-break-inside: avoid; }
        }
    </style>
</head>
<body>
    <!-- Student name panel -->
    <div id="student-info" class="ui-panel">
        <label for="name-input" style="font-weight: bold;">Name:</label>
        <input type="text" id="name-input" placeholder="Your name" />
    </div>

    <!-- Quantity chooser with toggle button -->
    <div id="quantity-wrapper" class="ui-panel">
        <div id="quantity-panel">
            <div><strong>Quantity (Teacher):</strong></div>
            <div style="display:flex; flex-wrap: wrap; gap: 8px;">
                <button class="qty-button" data-n="2">2</button>
                <button class="qty-button" data-n="3">3</button>
                <button class="qty-button" data-n="4">4</button>
                <button class="qty-button" data-n="5">5</button>
                <button class="qty-button" data-n="6">6</button>
                <button class="qty-button" data-n="7">7</button>
                <button class="qty-button" data-n="8">8</button>
                <button class="qty-button" data-n="9">9</button>
            </div>
            <button id="reveal-again" class="button" style="margin-top:6px;">Reveal Again</button>
            <small style="opacity:0.8;">Click a number to flash a random pattern. Blocks stay until answer is checked.</small>
        </div>
        <button id="toggle-qty-panel">❮</button>
    </div>

    <!-- Controls (same as previous) -->
    <div id="controls-wrapper">
        <button id="toggle-controls-button" class="button">Controls</button>
        <div id="collapsible-controls">
            <div id="color-changer" class="ui-panel">
                <button class="color-button" data-color="#f4f7f9" style="background-color: #f4f7f9;"></button>
                <button class="color-button" data-color="#fcf8e8" style="background-color: #fcf8e8;"></button>
                <button class="color-button" data-color="#2c3e50" style="background-color: #2c3e50;"></button>
            </div>
            <div id="teacher-tools" class="ui-panel">
                <span>Logged: <b id="attempts-count">0</b></span>
                <button id="export-button" class="button">Export</button>
                <button id="print-button" class="button">Print</button>
            </div>
            <div id="controls" class="ui-panel">
                <label for="slider">Size:</label>
                <input type="range" id="slider" min="10" max="150" value="25" />
                <span id="slider-value">25px</span>
            </div>
        </div>
    </div>

    <!-- Main grid container -->
    <div id="main-container">
        <div class="grid-group">
            <div id="green-grids-wrapper"></div>
        </div>
    </div>

    <!-- Answer area -->
    <div id="final-answer" class="ui-panel">
        <label for="answer-input" style="font-size: 1.2rem; font-weight:bold;">How many green blocks do you see?</label>
        <input type="number" id="answer-input" placeholder="Type here" />
        <div>
            <button id="check-button" class="button">Check Answer</button>
            <button id="reset-button" class="button">Reset</button>
        </div>
        <div id="feedback-message"></div>
        <!-- Scoreboard shows number of correct answers / total attempts -->
        <div id="score-board" style="font-size:1rem; font-weight:bold; margin-top:8px; text-align:center;">
            Score: <span id="score-correct">0</span>/<span id="score-total">0</span>
        </div>
    </div>

    <!-- Print container for worksheet export -->
    <div id="print-container"></div>

    <!-- Mute/unmute button -->
    <button id="mute-button" class="button">Mute</button>

    <script>
        const ELEVENLABS_API_KEY = '';
        const ELEVENLABS_VOICE_ID = '21m00Tcm4TlvDq8ikWAM';
        let browserFemaleVoice = null;
        let progressLog = [];

        // Global mute toggle for speech output
        window.isMuted = false;

        function loadBrowserVoice() {
            const voices = window.speechSynthesis.getVoices();
            browserFemaleVoice =
                voices.find(v => v.lang === 'en-GB' && v.name.includes('Female')) ||
                voices.find(v => v.lang === 'en-US' && v.name.includes('Female')) ||
                voices.find(v => v.lang.startsWith('en-'));
        }
        window.speechSynthesis.onvoiceschanged = loadBrowserVoice;
        loadBrowserVoice();

        function numberToWords(num) {
            const ones = ['zero','one','two','three','four','five','six','seven','eight','nine'];
            return ones[num] || String(num);
        }

        async function speak(text) {
            // Return a promise that resolves when the speech output finishes.
            // If muted, resolve immediately.
            if (window.isMuted) {
                return Promise.resolve();
            }
            return new Promise(async (resolve) => {
                const fallback = () => {
                    window.speechSynthesis.cancel();
                    const u = new SpeechSynthesisUtterance(text);
                    if (browserFemaleVoice) u.voice = browserFemaleVoice;
                    u.rate = 0.9;
                    u.onend = () => resolve();
                    window.speechSynthesis.speak(u);
                };
                if (!ELEVENLABS_API_KEY) {
                    fallback();
                    return;
                }
                try {
                    const response = await fetch(`https://api.elevenlabs.io/v1/text-to-speech/${ELEVENLABS_VOICE_ID}`, {
                        method: 'POST',
                        headers: { 'Accept': 'audio/mpeg', 'Content-Type': 'application/json', 'xi-api-key': ELEVENLABS_API_KEY },
                        body: JSON.stringify({
                            text,
                            model_id: "eleven_multilingual_v2",
                            voice_settings: { stability: 0.5, similarity_boost: 0.75 }
                        })
                    });
                    if (!response.ok) throw new Error(`API Error ${response.status}`);
                    const audio = new Audio(URL.createObjectURL(await response.blob()));
                    audio.onended = () => resolve();
                    audio.play();
                } catch (e) {
                    console.warn('ElevenLabs failed, using browser TTS.', e);
                    fallback();
                }
            });
        }

        document.addEventListener('DOMContentLoaded', () => {
            const nameInput = document.getElementById('name-input');
            const mainContainer = document.getElementById('main-container');
            const greenWrapper = document.getElementById('green-grids-wrapper');
            const slider = document.getElementById('slider');
            const sliderValue = document.getElementById('slider-value');
            const answerInput = document.getElementById('answer-input');
            const checkButton = document.getElementById('check-button');
            const resetButton = document.getElementById('reset-button');
            const feedbackMessage = document.getElementById('feedback-message');
            const colorChanger = document.getElementById('color-changer');
            const attemptsCount = document.getElementById('attempts-count');
            const exportButton = document.getElementById('export-button');
            const toggleControlsButton = document.getElementById('toggle-controls-button');
            const collapsibleControls = document.getElementById('collapsible-controls');
            const printButton = document.getElementById('print-button');
            const printContainer = document.getElementById('print-container');
            const qtyWrapper = document.getElementById('quantity-wrapper');
            const qtyPanel = document.getElementById('quantity-panel');
            const toggleQtyBtn = document.getElementById('toggle-qty-panel');
            const revealAgainBtn = document.getElementById('reveal-again');

            // Mute button
            const muteButton = document.getElementById('mute-button');
            muteButton.addEventListener('click', () => {
                window.isMuted = !window.isMuted;
                muteButton.textContent = window.isMuted ? 'Unmute' : 'Mute';
            });

            // Build 9 squares inside greenWrapper
            const squares = [];
            for (let i = 0; i < 9; i++) {
                const sq = document.createElement('div');
                sq.classList.add('square');
                greenWrapper.appendChild(sq);
                squares.push(sq);
            }

            // State variables
            let currentTarget = null;        // number of blocks in current pattern
            let lastChosenPositions = [];    // store chosen positions to reveal again
            let currentGroupSize = null;     // the group size selected by teacher
            let inMemoryMode = false;        // whether memory game is active

            // Score counters for student feedback
            let correctCount = 0;
            let attemptCount = 0;

            // Helpers
            function clearSquares() {
                squares.forEach(el => el.classList.remove('green'));
            }
            function samplePositions(n) {
                const indices = [...Array(9).keys()];
                for (let i = indices.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [indices[i], indices[j]] = [indices[j], indices[i]];
                }
                return indices.slice(0, n);
            }
            function generatePattern(n) {
                let chosen;
                let guard = 0;
                do {
                    chosen = samplePositions(n).sort((a,b) => a - b);
                    guard++;
                } while (guard < 10 && chosen.join('-') === lastChosenPositions.join('-'));
                lastChosenPositions = chosen;
                return chosen;
            }

            // Show pattern for memory game: no timer, stays until answered
            function showPattern(n) {
                clearSquares();
                const chosen = generatePattern(n);
                chosen.forEach(idx => squares[idx].classList.add('green'));
                currentTarget = n;
            }

            // Show next pattern when in memory mode
            function showNextPattern() {
                if (currentGroupSize) {
                    showPattern(currentGroupSize);
                    // Speak prompt without "Ready" and using present tense. Include student's name if provided.
                    const sName = nameInput.value.trim();
                    const who = sName ? `, ${sName}` : '';
                    const prompt = `How many green blocks do you see${who}?`;
                    speak(prompt);
                    // Automatically focus the answer input for quick entry
                    answerInput.focus();
                }
            }

            // Reveal again: just show same chosen positions again
            function revealAgain() {
                if (!lastChosenPositions.length) return;
                clearSquares();
                lastChosenPositions.forEach(idx => squares[idx].classList.add('green'));
            }

            // Event: Clicking on squares toggles only if not in memory mode
            greenWrapper.addEventListener('click', e => {
                if (!e.target.classList.contains('square')) return;
                if (inMemoryMode) return; // disable toggling while memory game running
                e.target.classList.toggle('green');
            });

            // Slider adjust square size
            slider.addEventListener('input', e => {
                const px = `${e.target.value}px`;
                document.documentElement.style.setProperty('--square-size', px);
                sliderValue.textContent = px;
            });

            // Reset button clears squares and resets state
            resetButton.addEventListener('click', () => {
                clearSquares();
                answerInput.value = '';
                feedbackMessage.textContent = '';
                feedbackMessage.className = '';
                currentTarget = null;
                inMemoryMode = false;
                currentGroupSize = null;
                qtyWrapper.classList.remove('collapsed');
                // Reset score counters
                correctCount = 0;
                attemptCount = 0;
                document.getElementById('score-correct').textContent = correctCount;
                document.getElementById('score-total').textContent = attemptCount;
            });

            // Colour theme toggle
            colorChanger.addEventListener('click', event => {
                const button = event.target.closest('.color-button');
                if (!button) return;
                const color = button.dataset.color;
                document.body.style.backgroundColor = color;
                document.body.classList.toggle('dark-mode', color === '#2c3e50');
            });

            // Controls panel toggle
            toggleControlsButton.addEventListener('click', () => {
                collapsibleControls.classList.toggle('visible');
            });

            // Export CSV of progress
            exportButton.addEventListener('click', () => {
                if (progressLog.length === 0) { alert('No progress has been logged yet.'); return; }
                const headers = ['Attempt #', 'Student Name', 'Target Value (Blocks)', 'Submitted Value (Typed)', 'Result'];
                let csvContent = headers.join(',') + '\n';
                const sName = (nameInput.value.trim() || 'Unnamed Student');
                progressLog.forEach((record, index) => {
                    const row = [index + 1, `"${sName}"`, record.targetValue, record.submittedValue, record.result];
                    csvContent += row.join(',') + '\n';
                });
                const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                const safeName = sName.replace(/ /g, '_');
                link.download = `progress_report_${safeName}_${new Date().toISOString().split('T')[0]}.csv`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            });

            // Print worksheet
            printButton.addEventListener('click', () => {
                const studentName = nameInput.value.trim() || 'Unnamed Student';
                const date = new Date().toLocaleString();
                let worksheetHTML = `<div style="font-family: 'Fredoka', sans-serif; padding: 20px;">`;
                worksheetHTML += `<div style="text-align: center; margin-bottom: 20px;">
                    <h1 style="font-size: 24px; font-weight: bold; margin-bottom: 20px;">Subitising Memory Worksheet</h1>
                    <p style="font-size: 18px; font-weight: bold; margin: 5px 0;">Name: ${studentName}</p>
                    <p style="font-size: 18px; font-weight: bold; margin: 5px 0;">Date: ${date}</p>
                </div>`;
                if (progressLog.length === 0) {
                    worksheetHTML += `<p style="text-align: center; margin-top: 40px;">No attempts were logged. Here is the current grid state:</p>`;
                    worksheetHTML += mainContainer.outerHTML;
                } else {
                    progressLog.forEach((record, index) => {
                        const resultColor = record.result === 'Correct' ? '#27ae60' : (record.result === 'Incorrect' ? '#c0392b' : '#555');
                        worksheetHTML += `<div class="print-attempt-block">
                                <h3 style="font-size: 20px; font-weight: bold; margin-bottom: 15px;">Attempt Log</h3>
                                <div style="display: flex; justify-content: space-around; font-size: 16px; margin-bottom: 20px;">
                                    <span><strong>Attempt #:</strong> ${index + 1}</span>
                                    <span><strong>Target Number (Blocks):</strong> ${record.targetValue}</span>
                                    <span><strong>Student's Answer:</strong> ${record.submittedValue}</span>
                                    <span style="color: ${resultColor}; font-weight: bold;">Result: ${record.result}</span>
                                </div>
                                ${record.gridState ? record.gridState.outerHTML : ''}
                            </div>`;
                    });
                }
                worksheetHTML += `</div>`;
                printContainer.innerHTML = worksheetHTML;
                window.print();
            });

            // Toggle quantity panel collapse/expand
            toggleQtyBtn.addEventListener('click', () => {
                qtyWrapper.classList.toggle('collapsed');
                // flip arrow
                toggleQtyBtn.textContent = qtyWrapper.classList.contains('collapsed') ? '❯' : '❮';
            });

            // Quantity selection: set group size and start memory game
            qtyPanel.addEventListener('click', (e) => {
                const btn = e.target.closest('.qty-button');
                if (!btn) return;
                const n = parseInt(btn.dataset.n);
                currentGroupSize = n;
                inMemoryMode = true;
                answerInput.value = '';
                feedbackMessage.textContent = '';
                feedbackMessage.className = '';
                qtyWrapper.classList.add('collapsed');
                toggleQtyBtn.textContent = '❯';
                // Clear progress log? maybe not
                showNextPattern();
            });

            // Reveal again button
            revealAgainBtn.addEventListener('click', () => {
                revealAgain();
            });

            // Check answer
            checkButton.addEventListener('click', () => {
                const studentName = nameInput.value.trim() || 'Unnamed Student';
                const userValue = parseInt(answerInput.value);
                let correctValue;
                if (inMemoryMode && currentTarget !== null) {
                    correctValue = currentTarget;
                } else {
                    // fallback to counting visible greens if no pattern active
                    correctValue = greenWrapper.querySelectorAll('.green').length;
                }
                const isCorrect = (userValue === correctValue);
                const numberInWords = numberToWords(correctValue);
                // Provide feedback message and voice
                if (isNaN(userValue)) {
                    feedbackMessage.textContent = 'Please type a number.';
                    feedbackMessage.className = 'incorrect';
                    speak(studentName !== 'Unnamed Student' ? `Please type a number, ${studentName}.` : 'Please type a number.');
                    return;
                }
                feedbackMessage.textContent = isCorrect
                    ? 'Correct! Well done!'
                    : `That's not quite right. The correct answer was ${correctValue}.`;
                feedbackMessage.className = isCorrect ? 'correct' : 'incorrect';

                // Build the spoken feedback text
                let speakText;
                if (isCorrect) {
                    speakText = studentName !== 'Unnamed Student'
                        ? `Correct! Well done, ${studentName}! You saw ${numberInWords}.`
                        : `Correct! Well done! You saw ${numberInWords}.`;
                } else {
                    speakText = studentName !== 'Unnamed Student'
                        ? `That's not quite right, let's try another, ${studentName}.`
                        : `That's not quite right, let's try another.`;
                }
                // Speak the feedback (respecting mute)
                speak(speakText);
                // Log progress
                const record = {
                    gridState: mainContainer.cloneNode(true),
                    targetValue: correctValue,
                    submittedValue: isNaN(userValue) ? 'N/A' : userValue,
                    result: isCorrect ? 'Correct' : 'Incorrect'
                };
                progressLog.push(record);
                attemptsCount.textContent = progressLog.length;

                // Update score counters
                attemptCount++;
                if (isCorrect) correctCount++;
                document.getElementById('score-correct').textContent = correctCount;
                document.getElementById('score-total').textContent = attemptCount;

                /*
                 * Wait an amount of time based on the length of the spoken
                 * feedback plus an additional 2 seconds before showing the next
                 * pattern. This avoids cutting off the speech when patterns
                 * advance. Since detecting the exact end of TTS reliably across
                 * browsers is difficult, estimate the reading time at roughly
                 * 0.45 seconds per word, then add a 2‑second pause.
                 */
                if (inMemoryMode && currentGroupSize) {
                    // Roughly count words in the spoken message
                    const wordCount = speakText.split(/\s+/).filter(Boolean).length;
                    // Estimated milliseconds for speech duration (0.45s per word) plus 2s pause
                    const delayMs = Math.round(wordCount * 450 + 2000);
                    setTimeout(() => {
                        answerInput.value = '';
                        feedbackMessage.textContent = '';
                        feedbackMessage.className = '';
                        showNextPattern();
                    }, delayMs);
                }
            });
        });
    </script>
</body>
</html>